/*
 * Lucene Query Grammar for PEG.js
 * ========================================
 *
 * This grammar supports many of the constructs contained in the Lucene Query Syntax.
 *
 * Supported features:
 * - conjunction operators (AND, OR, ||, &&, NOT, !)
 * - prefix operators (+, -)
 * - quoted values ("foo bar")
 * - named fields (foo:bar)
 * - range expressions (foo:[bar TO baz], foo:{bar TO baz})
 * - proximity search expressions ("foo bar"~5)
 * - boost expressions (foo^5, "foo bar"^5)
 * - fuzzy search expressions (foo~, foo~0.5)
 * - parentheses grouping ( (foo OR bar) AND baz )
 * - field groups ( foo:(bar OR baz) )
 *
 * The grammar will create a parser which returns an AST for the query in the form of a tree
 * of nodes, which are dictionaries. There are three basic types of expression dictionaries:
 *
 * A node expression generally has the following structure:
 *
 * {
 *     left: dictionary,     // field expression or node
 *     operator: string,      // operator value
 *     right: dictionary,     // field expression OR node
 *     field: string          // field name (for field group syntax) [OPTIONAL]
 * }
 *
 *
 * A field expression has the following structure:
 *
 * {
 *     field: string,         // field name
 *     term: string,          // term value
 *     prefix: string         // prefix operator (+/-) [OPTIONAL]
 *     boost: float           // boost value, (value > 1 must be integer) [OPTIONAL]
 *     similarity: float      // similarity value, (value must be > 0 and < 1) [OPTIONAL]
 *     proximity: integer     // proximity value [OPTIONAL]
 * }
 *
 *
 * A range expression has the following structure:
 *
 * {
 *     field: string,         // field name
 *     term_min: string,      // minimum value (left side) of range
 *     term_max: string,      // maximum value (right side) of range
 *     inclusive: boolean     // inclusive ([...]) or exclusive ({...})
 * }
 *
 * Other Notes:
 *
 * - For any field name, unnamed/default fields will have the value "<implicit>".
 * - Wildcards (fo*, f?o) and fuzzy search modifiers (foo~.8) will be part of the term value.
 * - Escaping is not supported and generally speaking, will break the parser.
 * - Conjunction operators that appear at the beginning of the query violate the logic of the
 *   syntax, and are currently "mostly" ignored. The last element will be returned.
 *
 *   For example:
 *       Query: OR
 *       Return: { "operator": "OR" }
 *
 *       Query: OR AND
 *       Return: { "operator": "AND" }
 *
 *       Query: OR AND foo
 *       Return: { "left": { "field": "<implicit>", "term": "foo" } }
 *
 *  To test the grammar, use the online parser generator at http://pegjs.majda.cz/online
 *
 */
 {
   function getTerm(term, options) {
     options = options || {};

     var result = { term: term };

     for (var key in options) {
       if (options.hasOwnProperty(key) && options[key]) {
         result[key] = options[key];
       }
     }

     return result;
   }

   // Chars that should be escaped in unquoted terms
   var escapedUnquotedTermChars = /\\(\s|\+|\-|&|\||!|\(|\)|\{|\}|\[|\]|\^|"|~|\*|\?|\:|\\|\/)/g;

   function unescapeTerm(term) {
     return term.replace(escapedUnquotedTermChars, '$1')
   }
 }

start
  = _* node:node+
    {
        return node[0];
    }
  / _*
    {
        return {};
    }
  / EOF
    {
        return {};
    }

node
  = operator:operator_exp EOF
    {
        return {
          operator: operator
        };
    }
  / operator:operator_exp right:node
    {
        return right;
    }
  / left:group_exp operator:operator_exp* right:node*
    {
      if (right.length === 0 && operator.length === 0) {
        return left;
      }

      var node = {
        left: left,
        operator: operator.length ? operator[0] :  '<implicit>',
      };

      if (right.length) {
        node.right = right[0].right === null ? right[0].left : right[0];
      }

      return node;
    }

group_exp
  = field_exp:field_exp _*
    {
        return field_exp;
    }
  / paren_exp

paren_exp
  = "(" node:node+ ")" _*
    {
        return node[0];
    }

field_exp
  = fieldname:fieldname? range:range_operator_exp
    {
        range.field = fieldname || "<implicit>";
        return range;
    }
  / fieldname:fieldname node:paren_exp
    {
        node.field = fieldname;
        return node;
    }
  / fieldname:fieldname? term:term
    {
        var fieldexp = {
          field: fieldname || "<implicit>"
        };

        for (var key in term) {
          if (term.hasOwnProperty(key)) {
            fieldexp[key] = term[key];
          }
        }

        return fieldexp;
    }

fieldname
  = fieldname:unquoted_term [:]
    {
        return fieldname;
    }

term
  = op:prefix_operator_exp? term:quoted_term proximity:proximity_modifier? boost:boost_modifier? _*
      {
        return getTerm(term, {
          proximity: proximity,
          boost: boost,
          prefix: op,
        });
      }
  / op:prefix_operator_exp? term:unquoted_term similarity:fuzzy_modifier? boost:boost_modifier? _*
      {
        return getTerm(term, {
          similarity: similarity,
          unquoted: true,
          boost: boost,
          prefix: op,
        });
      }
  / op:prefix_operator_exp? term:regexpr_term boost:boost_modifier? _*
      {
        return getTerm(term, {
          boost: boost,
          regexpr: true,
          prefix: op,
        });
      }



unquoted_term
  = term_start:term_start_char term:$term_char*
    {
      return unescapeTerm(term_start + term);
    }

term_start_char
  = '.' / escaped_term_char / '\\' / [^: \t\r\n\f\{\}()"+-/^~\[\]]

term_char
  = escaped_term_char / '+' / '-' / '/' / term_start_char

escaped_term_char
  = '\\ ' / '\\+' / '\\-' / '\\&' / '\\|'
  / '\\!' / '\\(' / '\\)' / '\\{'  / '\\}'
  / '\\[' / '\\]' / '\\^' / '\\"'  / '\\~'
  / '\\*' / '\\?' / '\\:' / '\\\\' / '\\/'

regexpr_term
  = '/' term:$regexpr_char+ '/'
    {
      return term;
    }

regexpr_char
  = '.' / '\\/' / [^/]


quoted_term
  = '"' term:$quoted_char* '"'
    {
        return term.replace(/\\"/g, '"');
    }

quoted_char
  = '\\"' / [^"]

proximity_modifier
  = '~' proximity:integer
    {
        return proximity;
    }

boost_modifier
  = '^' boost:number
    {
        return boost;
    }

fuzzy_modifier
  = '~' fuzziness:decimal?
    {
        return fuzziness == '' || fuzziness == undefined ? 0.5 : fuzziness;
    }


number = integer / decimal

decimal "decimal"
  = integer fraction exponent? {
    return parseFloat(text());
  }

integer "integer"
  = minus:minus? (zero / DIGIT1_9 DIGIT*) {
    return parseInt(text(), 10);
  }


exponent      = e (minus / plus)? DIGIT+
fraction      = decimal_point DIGIT+
DIGIT1_9      = [1-9]
DIGIT         = [0-9]
sign          = plus / minus
plus          = '+'
minus         = '-'
e             = [eE]
decimal_point = "."
zero = "0"


range_operator_exp
  = '[' term_min:range_term _* 'TO' _+ term_max:range_term ']'
    {
        return {
            term_min: term_min,
            term_max: term_max,
            inclusive: true,
            inclusive_min: true,
            inclusive_max: true,
        };
    }
  / '{' term_min:range_term _* 'TO' _+ term_max:range_term '}'
    {
        return {
            term_min: term_min,
            term_max: term_max,
            inclusive: false,
            inclusive_min: false,
            inclusive_max: false,
        };
    }
  / '{' term_min:range_term _* 'TO' _+ term_max:range_term ']'
    {
        return {
            term_min: term_min,
            term_max: term_max,
            inclusive: false,
            inclusive_min: false,
            inclusive_max: true,
        };
    }
  / '[' term_min:range_term _* 'TO' _+ term_max:range_term '}'
    {
        return {
            term_min: term_min,
            term_max: term_max,
            inclusive: false,
            inclusive_min: true,
            inclusive_max: false,
        };
    }

range_term
  = range_unquoted_term
  / number

range_unquoted_term
  = term_start:range_term_start_char term:$range_term_char*
    {
      return term_start + term;
    }

range_term_start_char
  = '.' / '\\' / [^: \t\r\n\f\{\}()"/^~\[\]]

range_term_char
  = '/' / ':' / range_term_start_char

operator_exp
  = _* operator:operator _+
    {
        return operator;
    }
  / _* operator:operator EOF
    {
        return operator;
    }

operator
  = 'OR'
  / 'AND'
  / 'NOT'
  / '||' { return 'OR'; }
  / '&&' { return 'AND'; }
  / '!' { return 'NOT'}

prefix_operator_exp
  = _* operator:prefix_operator
    {
        return operator;
    }

prefix_operator
  = '+'
  / '-'

_ "whitespace"
  = [ \t\r\n\f]+

EOF
  = !.
